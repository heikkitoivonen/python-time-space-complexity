# Python 3.14 - Complexity & Optimizations

Python 3.14 was released October 2025 with new max-heap support and continued performance improvements.

## New Features Affecting Complexity

### Max-Heap Support in heapq

Python 3.14 adds native max-heap functions to the `heapq` module:

```python
import heapq

# New max-heap operations (Python 3.14+)
data = [3, 1, 4, 1, 5, 9, 2, 6]

heapq.heapify_max(data)          # O(n) - Transform to max-heap
heapq.heappush_max(data, 10)     # O(log n) - Add to max-heap
max_val = heapq.heappop_max(data) # O(log n) - Remove and return max
heapq.heapreplace_max(data, 7)   # O(log n) - Pop max, push new
heapq.heappushpop_max(data, 8)   # O(log n) - Push, then pop max

# Previously required negation workaround:
# Old: heapq.heappush(heap, -value)  # Negate for max-heap
# New: heapq.heappush_max(heap, value)  # Direct max-heap
```

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| `heapify_max(x)` | O(n) | O(1) | In-place max-heap transformation |
| `heappush_max(heap, item)` | O(log n) | O(1) | Add item to max-heap |
| `heappop_max(heap)` | O(log n) | O(1) | Remove and return max item |
| `heapreplace_max(heap, item)` | O(log n) | O(1) | Pop max then push |
| `heappushpop_max(heap, item)` | O(log n) | O(1) | Push then pop max |

### New Type Conversion Methods

```python
# float.from_number() - O(1)
f = float.from_number(42)      # Converts number to float
f = float.from_number(3.14)    # Returns float

# complex.from_number() - O(1)  
c = complex.from_number(42)    # Converts to complex

# Raises TypeError for non-numeric types (stricter than float())
float.from_number("3.14")      # TypeError
```

### bytes.fromhex() Enhancement

```python
# Now accepts bytes input (previously only str)
data = bytes.fromhex(b"48656c6c6f")  # O(n)
data = bytearray.fromhex(b"48656c6c6f")  # O(n)
```

## Performance Improvements

### Incremental Garbage Collection

```python
# GC pause times reduced by order of magnitude for large heaps
# No code changes needed - automatic improvement

# Impact: More consistent latency for long-running applications
# Complexity unchanged, but real-world pause times much shorter
```

### asyncio Optimization

```python
import asyncio

# 10-20% faster task scheduling
# Per-thread doubly linked list for tasks
# Reduced memory usage

async def main():
    tasks = [asyncio.create_task(work()) for _ in range(1000)]
    await asyncio.gather(*tasks)  # Faster scheduling
```

### uuid Performance

```python
import uuid

# uuid3() and uuid5(): ~40% faster for 16-byte names
# uuid4(): ~30% faster
name_uuid = uuid.uuid5(uuid.NAMESPACE_DNS, "example.com")
random_uuid = uuid.uuid4()  # 30% faster
```

### zlib on Windows

```python
import zlib

# Windows: Now uses zlib-ng for better performance
# All compression levels faster
# Note: Z_BEST_SPEED (level 1) may compress less than before
data = zlib.compress(b"data" * 1000, level=6)
```

## Complexity Characteristics

All standard complexities preserved from 3.13:

| Operation | Complexity | Status |
|-----------|-----------|--------|
| `list.append()` | O(1) amortized | Unchanged |
| `dict[key]` | O(1) avg | Unchanged |
| `set.add()` | O(1) amortized | Unchanged |
| `heapq.heappush()` | O(log n) | Unchanged |
| `heapq.heappush_max()` | O(log n) | **New** |

## Deferred Annotation Evaluation (PEP 649)

```python
# Annotations no longer evaluated at function definition time
# Reduces import overhead for heavily annotated code

def process(data: list[ComplexType]) -> Result:
    pass

# ComplexType not evaluated until annotations accessed
# Reduces memory for unused annotations
```

## Deprecations

```python
# Deprecated:
# - calendar.January/February (use calendar.JANUARY/FEBRUARY)
# - codecs.open() (use built-in open())
# - Passing complex as real/imag to complex()

# Pending removal:
# - typing._UnionGenericAlias (Python 3.17)
```

## Recommendations

### When to Use Max-Heap Functions

```python
import heapq

# Use heapify_max() for priority queues needing max first
tasks = [(1, "low"), (5, "high"), (3, "medium")]
heapq.heapify_max(tasks)
urgent = heapq.heappop_max(tasks)  # (5, "high")

# Use for top-k smallest (maintain max-heap of k items)
def k_smallest(items, k):
    heap = items[:k]
    heapq.heapify_max(heap)
    for item in items[k:]:
        if item < heap[0]:
            heapq.heapreplace_max(heap, item)
    return sorted(heap)
```

### When to Upgrade

**Upgrade to 3.14 if:**
- ✅ Need native max-heap support
- ✅ Large heap applications (better GC pauses)
- ✅ UUID-heavy workloads
- ✅ Windows zlib performance matters

**Stay on 3.13 if:**
- ✅ Production stability priority
- ✅ Package compatibility concerns
- ✅ Testing free-threading builds

## End of Life

- **Release**: October 2025
- **Bugfix Support**: Until October 2027
- **Security Support**: Until October 2030

## Related Documentation

- [heapq Module](../stdlib/heapq.md)
- [Python 3.13](py313.md)
- [CPython Implementation](../implementations/cpython.md)
